function [Y_DC, Y_AC, Cb_DC, Cb_AC, Cr_DC, Cr_AC] = ...
    invSTEP5(YDC_Str, YAC_Str, CbDC_Str, CbAC_Str, CrDC_Str, CrAC_Str)
    Y_DC = YDC(YDC_Str);
    Y_AC = YAC(YAC_Str);
    Cb_DC = CDC(CbDC_Str);
    Cb_AC = CAC(CbAC_Str);
    Cr_DC = CDC(CrDC_Str);
    Cr_AC = CAC(CrAC_Str);
end



function Y_DC = YDC(YDC_Str)

    YDC_Str = split(YDC_Str, '');
    YDC_Str = YDC_Str(2:end-1);
    
    keys = {
    '00'
    '010'
    '011'
    '100'
    '101'
    '110'
    '1110'
    '11110'
    '111110'
    '1111110'
    '11111110'
    '111111110'};

    lower_bound = 2.^(0:1:10);
    M = containers.Map(keys, 0:1:11);
    
    subs = '';
    Y_DC = zeros(1, length(YDC_Str));
    index = 1;
    i = 1;
    
    while i <= length(YDC_Str)
        subs = strcat(subs, YDC_Str(i));
        i = i + 1;
    
        if isKey(M, subs)
            group = M(subs);
            subs = YDC_Str(i: i + group - 1);
            i = i + group;
            if group == 0
                Y_DC(index) = 0;
            elseif group == 1
                if subs == '1'
                    Y_DC(index) = 1;
                else
                    Y_DC(index) = -1;
                end   
            else
                X = int8(zeros(1, group - 1));
                for j = 1: group - 1
                    X(j) = char(subs(j + 1)) - '0';
                end
    
                number = lower_bound(group) + bit2int(X', group - 1);
                if subs(1) == '1'
                    Y_DC(index) = number;
                else
                    Y_DC(index) = -1 * number;
                end
            end
            index = index + 1;
            subs = '';
        end
    end
    Y_DC(index:end) = [];
end
function Y_AC = YAC(YAC_Str)

    keys = { 
    % '1010';
    '00';
    '01';
    '100';
    '1011';
    '11010';
    '1111000';
    '11111000';
    '1111110110';
    '1111111110000010';
    '1111111110000011';
    '1100';
    '11011';
    '1111001';
    '111110110';
    '11111110110';
    '1111111110000100';
    '1111111110000101';
    '1111111110000110';
    '1111111110000111';
    '1111111110001000';
    '11100';
    '11111001';
    '1111110111';
    '111111110100';
    '1111111110001001';
    '1111111110001010';
    '1111111110001011';
    '1111111110001100';
    '1111111110001101';
    '1111111110001110';
    '111010';
    '111110111';
    '111111110101';
    '1111111110001111';
    '1111111110010000';
    '1111111110010001';
    '1111111110010010';
    '1111111110010011';
    '1111111110010100';
    '1111111110010101';
    '111011';
    '1111111000';
    '1111111110010110';
    '1111111110010111';
    '1111111110011000';
    '1111111110011001';
    '1111111110011010';
    '1111111110011011';
    '1111111110011100';
    '1111111110011101';
    '1111010';
    '11111110111';
    '1111111110011110';
    '1111111110011111';
    '1111111110100000';
    '1111111110100001';
    '1111111110100010';
    '1111111110100011';
    '1111111110100100';
    '1111111110100101';
    '1111011';
    '111111110110';
    '1111111110100110';
    '1111111110100111';
    '1111111110101000';
    '1111111110101001';
    '1111111110101010';
    '1111111110101011';
    '1111111110101100';
    '1111111110101101';
    '11111010';
    '111111110111';
    '1111111110101110';
    '1111111110101111';
    '1111111110110000';
    '1111111110110001';
    '1111111110110010';
    '1111111110110011';
    '1111111110110100';
    '1111111110110101';
    '111111000';
    '111111111000000';
    '1111111110110110';
    '1111111110110111';
    '1111111110111000';
    '1111111110111001';
    '1111111110111010';
    '1111111110111011';
    '1111111110111100';
    '1111111110111101';
    '111111001';
    '1111111110111110';
    '1111111110111111';
    '1111111111000000';
    '1111111111000001';
    '1111111111000010';
    '1111111111000011';
    '1111111111000100';
    '1111111111000101';
    '1111111111000110';
    '111111010';
    '1111111111000111';
    '1111111111001000';
    '1111111111001001';
    '1111111111001010';
    '1111111111001011';
    '1111111111001100';
    '1111111111001101';
    '1111111111001110';
    '1111111111001111';
    '1111111001';
    '1111111111010000';
    '1111111111010001';
    '1111111111010010';
    '1111111111010011';
    '1111111111010100';
    '1111111111010101';
    '1111111111010110';
    '1111111111010111';
    '1111111111011000';
    '1111111010';
    '1111111111011001';
    '1111111111011010';
    '1111111111011011';
    '1111111111011100';
    '1111111111011101';
    '1111111111011110';
    '1111111111011111';
    '1111111111100000';
    '1111111111100001';
    '11111111000';
    '1111111111100010';
    '1111111111100011';
    '1111111111100100';
    '1111111111100101';
    '1111111111100110';
    '1111111111100111';
    '1111111111101000';
    '1111111111101001';
    '1111111111101010';
    '1111111111101011';
    '1111111111101100';
    '1111111111101101';
    '1111111111101110';
    '1111111111101111';
    '1111111111110000';
    '1111111111110001';
    '1111111111110010';
    '1111111111110011';
    '1111111111110100';
    % '11111111001';
    '1111111111110101';
    '1111111111110110';
    '1111111111110111';
    '1111111111111000';
    '1111111111111001';
    '1111111111111010';
    '1111111111111011';
    '1111111111111100';
    '1111111111111101';
    '1111111111111110'};
    
    values = cell(160, 1);
    index = 1;
    
    for i = 0:15
        for j = 1:10
            values{index} = [i, j];
            index = index + 1;
        end
    end
    
    % two map, one is for length == 16, one is for others
    
    % M = containers.Map(keys, values);
    
    Maps = cell(1, 16);
    
    
    for len = 1:16
        l = [];
        for i = 1:160
            if strlength(keys{i}) == len
                l = [l i];
            end
        end
        if isempty(l)
            Maps{len} = containers.Map('Nothing', 0);
        else
            Maps{len} = containers.Map(keys(l), values(l));
        end
        
    end
    
    Maps{4}('1010') = [0, 0];
    Maps{11}('11111111001') = [16, 0];
    
    % ==============================================
    
    YAC_Str = split(YAC_Str, '');
    YAC_Str = YAC_Str(2:end-1);

    lower_bound = 2.^(0:1:10);
    subs = '';
    Y_AC = zeros(length(YAC_Str), 2);
    index = 1;
    i = 1;
    
    while i <= length(YAC_Str)
    
        subs = strcat(subs, YAC_Str(i));
        i = i + 1;
        
        if isKey(Maps{strlength(subs)}, subs)
    
            pairs = Maps{strlength(subs)}(subs);
            zero = pairs(1);
            group = pairs(2);
    
            subs = YAC_Str(i: i + group - 1);
            i = i + group;
    
            if group == 0
                Y_AC(index, 1) = zero + Y_AC(index, 1);
                Y_AC(index, 2) = 0 + Y_AC(index, 2);
                if zero == 16
                    index = index - 1;
                end
            elseif group == 1
                if subs == '1'
                    Y_AC(index, 1) = zero + Y_AC(index, 1);
                    Y_AC(index, 2) = 1 + Y_AC(index, 2);
                else
                    Y_AC(index, 1) = zero + Y_AC(index, 1);
                    Y_AC(index, 2) = -1 + Y_AC(index, 2);
                end   
            else
                X = int8(zeros(1, group - 1));
                for j = 1: group - 1
                    X(j) = char(subs(j + 1)) - '0';
                end
     
                number = lower_bound(group) + bit2int(X', group - 1);
                if subs(1) == '1'
                    Y_AC(index, 1) = zero + Y_AC(index, 1);
                    Y_AC(index, 2) = number + Y_AC(index, 2);
                else
                    Y_AC(index, 1) = zero + Y_AC(index, 1);
                    Y_AC(index, 2) = -number + Y_AC(index, 2);
                end
            end
            index = index + 1;
            subs = '';
        end
    end
    Y_AC(index:end, :) = [];
end
function C_DC = CDC(CDC_Str)
    

    keys={
        '00'
        '01'
        '10'
        '110'
        '1110'
        '11110'
        '111110'
        '1111110'
        '11111110'
        '111111110'
        '1111111110'
        '11111111110'};  

    lower_bound = 2.^(0:1:10);
    M = containers.Map(keys, 0:1:11);

    CDC_Str = split(CDC_Str, '');
    CDC_Str = CDC_Str(2:end-1);
    subs = '';
    C_DC = zeros(1, length(CDC_Str));
    index = 1;
    i = 1;
    
    while i <= length(CDC_Str)
        subs = strcat(subs, CDC_Str(i));
        i = i + 1;
    
        if isKey(M, subs)
            group = M(subs);
            subs = CDC_Str(i: i + group - 1);
            i = i + group;
            if group == 0
                C_DC(index) = 0;
            elseif group == 1
                if subs == '1'
                    C_DC(index) = 1;
                else
                    C_DC(index) = -1;
                end   
            else
                X = int8(zeros(1, group - 1));
                for j = 1: group - 1
                    X(j) = char(subs(j + 1)) - '0';
                end
    
                number = lower_bound(group) + bit2int(X', group - 1);
                if subs(1) == '1'
                    C_DC(index) = number;
                else
                    C_DC(index) = -1 * number;
                end
            end
            index = index + 1;
            subs = '';
        end
    end
    C_DC(index:end) = [];
end
function C_AC = CAC(CAC_Str)

    keys = { 
    % '00';
    '01';
    '100';
    '1010';
    '11000';
    '11001';
    '111000';
    '1111000';
    '111110100';
    '1111110110';
    '111111110100';
    '1011';
    '111001';
    '11110110';
    '111110101';
    '11111110110';
    '111111110101';
    '1111111110001000';
    '1111111110001001';
    '1111111110001010';
    '1111111110001011';
    '11010';
    '11110111';
    '1111110111';
    '111111110110';
    '111111111000010';
    '1111111110001100';
    '1111111110001101';
    '1111111110001110';
    '1111111110001111';
    '1111111110010000';
    '11011';
    '11111000';
    '1111111000';
    '111111110111';
    '1111111110010001';
    '1111111110010010';
    '1111111110010011';
    '1111111110010100';
    '1111111110010101';
    '1111111110010110';
    '111010';
    '111110110';
    '1111111110010111';
    '1111111110011000';
    '1111111110011001';
    '1111111110011010';
    '1111111110011011';
    '1111111110011100';
    '1111111110011101';
    '1111111110011110';
    '111011';
    '1111111001';
    '1111111110011111';
    '1111111110100000';
    '1111111110100001';
    '1111111110100010';
    '1111111110100011';
    '1111111110100100';
    '1111111110100101';
    '1111111110100110';
    '1111001';
    '11111110111';
    '1111111110100111';
    '1111111110101000';
    '1111111110101001';
    '1111111110101010';
    '1111111110101011';
    '1111111110101100';
    '1111111110101101';
    '1111111110101110';
    '1111010';
    '11111111000';
    '1111111110101111';
    '1111111110110000';
    '1111111110110001';
    '1111111110110010';
    '1111111110110011';
    '1111111110110100';
    '1111111110110101';
    '1111111110110110';
    '11111001';
    '1111111110110111';
    '1111111110111000';
    '1111111110111001';
    '1111111110111010';
    '1111111110111011';
    '1111111110111100';
    '1111111110111101';
    '1111111110111110';
    '1111111110111111';
    '111110111';
    '1111111111000000';
    '1111111111000001';
    '1111111111000010';
    '1111111111000011';
    '1111111111000100';
    '1111111111000101';
    '1111111111000110';
    '1111111111000111';
    '1111111111001000';
    '111111000';
    '1111111111001001';
    '1111111111001010';
    '1111111111001011';
    '1111111111001100';
    '1111111111001101';
    '1111111111001110';
    '1111111111001111';
    '1111111111010000';
    '1111111111010001';
    '111111001';
    '1111111111010010';
    '1111111111010011';
    '1111111111010100';
    '1111111111010101';
    '1111111111010110';
    '1111111111010111';
    '1111111111011000';
    '1111111111011001';
    '1111111111011010';
    '111111010';
    '1111111111011011';
    '1111111111011100';
    '1111111111011101';
    '1111111111011110';
    '1111111111011111';
    '1111111111100000';
    '1111111111100001';
    '1111111111100010';
    '1111111111100011';
    '11111111001';
    '1111111111100100';
    '1111111111100101';
    '1111111111100110';
    '1111111111100111';
    '1111111111101000';
    '1111111111101001';
    '1111111111101010';
    '1111111111101011';
    '1111111111101100';
    '11111111100000';
    '1111111111101101';
    '1111111111101110';
    '1111111111101111';
    '1111111111110000';
    '1111111111110001';
    '1111111111110010';
    '1111111111110011';
    '1111111111110100';
    '1111111111110101';
    % '1111111010';
    '111111111000011';
    '1111111111110110';
    '1111111111110111';
    '1111111111111000';
    '1111111111111001';
    '1111111111111010';
    '1111111111111011';
    '1111111111111100';
    '1111111111111101';
    '1111111111111110'};
    
    values = cell(160, 1);
    index = 1;
    
    for i = 0:15
        for j = 1:10
            values{index} = [i, j];
            index = index + 1;
        end
    end
    
    % two map, one is for length == 16, one is for others
    
    % M = containers.Map(keys, values);
    
    Maps = cell(1, 16);
    
    
    for len = 1:16
        l = [];
        for i = 1:160
            if strlength(keys{i}) == len
                l = [l i];
            end
        end
        if isempty(l)
            Maps{len} = containers.Map('Nothing', 0);
        else
            Maps{len} = containers.Map(keys(l), values(l));
        end
        
    end
    
    Maps{2}('00') = [0, 0];
    Maps{10}('1111111010') = [16, 0];
    
    % ==============================================
    
    CAC_Str = split(CAC_Str, '');
    CAC_Str = CAC_Str(2:end-1);

    lower_bound = 2.^(0:1:10);
    subs = '';
    C_AC = zeros(length(CAC_Str), 2);
    index = 1;
    i = 1;
    
    while i <= length(CAC_Str)

        subs = strcat(subs, CAC_Str(i));
        i = i + 1;
        
        if isKey(Maps{strlength(subs)}, subs)
    
            pairs = Maps{strlength(subs)}(subs);
            zero = pairs(1);
            group = pairs(2);
            subs = CAC_Str(i: i + group - 1);
            i = i + group;
    
            if group == 0
                C_AC(index, 1) = zero + C_AC(index, 1);
                C_AC(index, 2) = 0 + C_AC(index, 2);
                if zero == 16
                    index = index - 1;
                end
            elseif group == 1
                if subs == '1'
                    C_AC(index, 1) = zero + C_AC(index, 1);
                    C_AC(index, 2) = 1 + C_AC(index, 2);
                else
                    C_AC(index, 1) = zero + C_AC(index, 1);
                    C_AC(index, 2) = -1 + C_AC(index, 2);
                end   
            else
                X = int8(zeros(1, group - 1));
                for j = 1: group - 1
                    X(j) = char(subs(j + 1)) - '0';
                end
     
                number = lower_bound(group) + bit2int(X', group - 1);
                if subs(1) == '1'
                    C_AC(index, 1) = zero + C_AC(index, 1);
                    C_AC(index, 2) = number + C_AC(index, 2);
                else
                    C_AC(index, 1) = zero + C_AC(index, 1);
                    C_AC(index, 2) = -number + C_AC(index, 2);
                end
            end
            index = index + 1;
            subs = '';
        end
    end

    C_AC(index:end, :) = [];
end


